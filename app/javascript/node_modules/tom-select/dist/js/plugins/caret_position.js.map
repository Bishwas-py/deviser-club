{"version":3,"file":"caret_position.js","sources":["../../../node_modules/@orchidjs/sifter/lib/diacritics.ts","../../../node_modules/@orchidjs/sifter/lib/utils.ts","../../../src/vanilla.ts","../../../src/plugins/caret_position/plugin.ts"],"sourcesContent":["\n// @ts-ignore TS2691 \"An import path cannot end with a '.ts' extension\"\nimport { escape_regex } from './utils.ts';\n\ntype TDiacraticList = {[key:string]:string};\n\n// https://github.com/andrewrk/node-diacritics/blob/master/index.js\n\nvar latin_pat:RegExp;\nconst accent_pat = '[\\u0300-\\u036F\\u{b7}\\u{2be}]'; // \\u{2bc}\nconst accent_reg = new RegExp(accent_pat,'gu');\nvar diacritic_patterns:TDiacraticList;\n\nconst latin_convert:TDiacraticList = {\n\t'æ': 'ae',\n\t'ⱥ': 'a',\n\t'ø': 'o',\n};\n\nconst convert_pat = new RegExp(Object.keys(latin_convert).join('|'),'gu');\n\nconst code_points:[[number,number]] = [[ 0, 65535 ]];\n\n/**\n * Remove accents\n * via https://github.com/krisk/Fuse/issues/133#issuecomment-318692703\n *\n */\nexport const asciifold = (str:string):string => {\n\treturn str\n\t\t.normalize('NFKD')\n\t\t.replace(accent_reg, '')\n\t\t.toLowerCase()\n\t\t.replace(convert_pat,function(foreignletter) {\n\t\t\treturn latin_convert[foreignletter];\n\t\t});\n};\n\n/**\n * Convert array of strings to a regular expression\n *\tex ['ab','a'] => (?:ab|a)\n * \tex ['a','b'] => [ab]\n *\n */\nexport const arrayToPattern = (chars:string[],glue:string='|'):string =>{\n\n\tif( chars.length == 1 ){\n\t\treturn chars[0];\n\t}\n\n\tvar longest = 1;\n\tchars.forEach((a)=>{longest = Math.max(longest,a.length)});\n\n\tif( longest == 1 ){\n\t\treturn '['+chars.join('')+']';\n\t}\n\n\treturn '(?:'+chars.join(glue)+')';\n};\n\nexport const escapeToPattern = (chars:string[]):string =>{\n\tconst escaped = chars.map((diacritic) => escape_regex(diacritic));\n\treturn arrayToPattern(escaped);\n};\n\n/**\n * Get all possible combinations of substrings that add up to the given string\n * https://stackoverflow.com/questions/30169587/find-all-the-combination-of-substrings-that-add-up-to-the-given-string\n *\n */\nexport const allSubstrings = (input:string):string[][] => {\n\n    if( input.length === 1) return [[input]];\n\n    var result:string[][] = [];\n    allSubstrings(input.substring(1)).forEach(function(subresult) {\n        var tmp = subresult.slice(0);\n        tmp[0] = input.charAt(0) + tmp[0];\n        result.push(tmp);\n\n        tmp = subresult.slice(0);\n        tmp.unshift(input.charAt(0));\n        result.push(tmp);\n    });\n\n    return result;\n}\n\n/**\n * Generate a list of diacritics from the list of code points\n *\n */\nexport const generateDiacritics = (code_points:[[number,number]]):TDiacraticList => {\n\n\tvar diacritics:{[key:string]:string[]} = {};\n\tcode_points.forEach((code_range)=>{\n\n\t\tfor(let i = code_range[0]; i <= code_range[1]; i++){\n\n\t\t\tlet diacritic\t= String.fromCharCode(i);\n\t\t\tlet\tlatin\t\t= asciifold(diacritic);\n\n\t\t\tif( latin == diacritic.toLowerCase() ){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// skip when latin is a string longer than 3 characters long\n\t\t\t// bc the resulting regex patterns will be long\n\t\t\t// eg:\n\t\t\t// latin صلى الله عليه وسلم length 18 code point 65018\n\t\t\t// latin جل جلاله length 8 code point 65019\n\t\t\tif( latin.length > 3 ){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif( !(latin in diacritics) ){\n\t\t\t\tdiacritics[latin] = [latin];\n\t\t\t}\n\n\t\t\tvar patt = new RegExp( escapeToPattern(diacritics[latin]),'iu');\n\t\t\tif( diacritic.match(patt) ){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdiacritics[latin].push(diacritic);\n\t\t}\n\t});\n\n\t// filter out if there's only one character in the list\n\tlet latin_chars = Object.keys(diacritics);\n\tfor( let i = 0; i < latin_chars.length; i++){\n\t\tconst latin = latin_chars[i];\n\t\tif( diacritics[latin].length < 2 ){\n\t\t\tdelete diacritics[latin];\n\t\t}\n\t}\n\n\n\t// latin character pattern\n\t// match longer substrings first\n\tlatin_chars\t\t= Object.keys(diacritics).sort((a, b) => b.length - a.length );\n\tlatin_pat\t\t= new RegExp('('+ escapeToPattern(latin_chars) + accent_pat + '*)','gu');\n\n\n\t// build diacritic patterns\n\t// ae needs:\n\t//\t(?:(?:ae|Æ|Ǽ|Ǣ)|(?:A|Ⓐ|Ａ...)(?:E|ɛ|Ⓔ...))\n\tvar diacritic_patterns:TDiacraticList = {};\n\tlatin_chars.sort((a,b) => a.length -b.length).forEach((latin)=>{\n\n\t\tvar substrings\t= allSubstrings(latin);\n\t\tvar pattern = substrings.map((sub_pat)=>{\n\n\t\t\tsub_pat = sub_pat.map((l)=>{\n\t\t\t\tif( diacritics.hasOwnProperty(l) ){\n\t\t\t\t\treturn escapeToPattern(diacritics[l]);\n\t\t\t\t}\n\t\t\t\treturn l;\n\t\t\t});\n\n\t\t\treturn arrayToPattern(sub_pat,'');\n\t\t});\n\n\t\tdiacritic_patterns[latin] = arrayToPattern(pattern);\n\t});\n\n\n\treturn diacritic_patterns;\n}\n\n/**\n * Expand a regular expression pattern to include diacritics\n * \teg /a/ becomes /aⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐɑAⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ/\n *\n */\nexport const diacriticRegexPoints = (regex:string):string => {\n\n\tif( diacritic_patterns === undefined ){\n\t\tdiacritic_patterns = generateDiacritics(code_points);\n\t}\n\n\tconst decomposed\t\t= regex.normalize('NFKD').toLowerCase();\n\n\treturn decomposed.split(latin_pat).map((part:string)=>{\n\n\t\t// \"ﬄ\" or \"ffl\"\n\t\tconst no_accent = asciifold(part);\n\t\tif( no_accent == '' ){\n\t\t\treturn '';\n\t\t}\n\n\t\tif( diacritic_patterns.hasOwnProperty(no_accent) ){\n\t\t\treturn diacritic_patterns[no_accent];\n\t\t}\n\n\t\treturn part;\n\t}).join('');\n\n}\n","\n// @ts-ignore TS2691 \"An import path cannot end with a '.ts' extension\"\nimport { asciifold } from './diacritics.ts';\n\n// @ts-ignore TS2691 \"An import path cannot end with a '.ts' extension\"\nimport * as T from './types.ts';\n\n\n/**\n * A property getter resolving dot-notation\n * @param  {Object}  obj     The root object to fetch property on\n * @param  {String}  name    The optionally dotted property name to fetch\n * @return {Object}          The resolved property value\n */\nexport const getAttr = (obj:{[key:string]:any}, name:string ) => {\n    if (!obj ) return;\n    return obj[name];\n};\n\n/**\n * A property getter resolving dot-notation\n * @param  {Object}  obj     The root object to fetch property on\n * @param  {String}  name    The optionally dotted property name to fetch\n * @return {Object}          The resolved property value\n */\nexport const getAttrNesting = (obj:{[key:string]:any}, name:string ) => {\n    if (!obj ) return;\n    var part, names = name.split(\".\");\n\twhile( (part = names.shift()) && (obj = obj[part]));\n    return obj;\n};\n\n/**\n * Calculates how close of a match the\n * given value is against a search token.\n *\n */\nexport const scoreValue = (value:string, token:T.Token, weight:number ):number => {\n\tvar score, pos;\n\n\tif (!value) return 0;\n\n\tvalue = value + '';\n\tpos = value.search(token.regex);\n\tif (pos === -1) return 0;\n\n\tscore = token.string.length / value.length;\n\tif (pos === 0) score += 0.5;\n\n\treturn score * weight;\n};\n\n/**\n *\n * https://stackoverflow.com/questions/63006601/why-does-u-throw-an-invalid-escape-error\n */\nexport const escape_regex = (str:string):string => {\n\treturn (str + '').replace(/([\\$\\(\\)\\*\\+\\.\\?\\[\\]\\^\\{\\|\\}\\\\])/gu, '\\\\$1');\n};\n\n\n/**\n * Cast object property to an array if it exists and has a value\n *\n */\nexport const propToArray = (obj:{[key:string]:any}, key:string) => {\n\tvar value = obj[key];\n\n\tif( typeof value == 'function' ) return value;\n\n\tif( value && !Array.isArray(value) ){\n\t\tobj[key] = [value];\n\t}\n}\n\n\n/**\n * Iterates over arrays and hashes.\n *\n * ```\n * iterate(this.items, function(item, id) {\n *    // invoked for each item\n * });\n * ```\n *\n */\nexport const iterate = (object:[]|{[key:string]:any}, callback:(value:any,key:number|string)=>any) => {\n\n\tif ( Array.isArray(object)) {\n\t\tobject.forEach(callback);\n\n\t}else{\n\n\t\tfor (var key in object) {\n\t\t\tif (object.hasOwnProperty(key)) {\n\t\t\t\tcallback(object[key], key);\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n\nexport const cmp = (a:number|string, b:number|string) => {\n\tif (typeof a === 'number' && typeof b === 'number') {\n\t\treturn a > b ? 1 : (a < b ? -1 : 0);\n\t}\n\ta = asciifold(a + '').toLowerCase();\n\tb = asciifold(b + '').toLowerCase();\n\tif (a > b) return 1;\n\tif (b > a) return -1;\n\treturn 0;\n};\n","\nimport { iterate } from '@orchidjs/sifter/lib/utils';\n\n/**\n * Return a dom element from either a dom query string, jQuery object, a dom element or html string\n * https://stackoverflow.com/questions/494143/creating-a-new-dom-element-from-an-html-string-using-built-in-dom-methods-or-pro/35385518#35385518\n *\n * param query should be {}\n */\nexport const getDom = ( query:any ):HTMLElement => {\n\n\tif( query.jquery ){\n\t\treturn query[0];\n\t}\n\n\tif( query instanceof HTMLElement ){\n\t\treturn query;\n\t}\n\n\tif( isHtmlString(query) ){\n\t\tlet div = document.createElement('div');\n\t\tdiv.innerHTML = query.trim(); // Never return a text node of whitespace as the result\n\t\treturn div.firstChild as HTMLElement;\n\t}\n\n\treturn document.querySelector(query);\n};\n\nexport const isHtmlString = (arg:any): boolean => {\n\tif( typeof arg === 'string' && arg.indexOf('<') > -1 ){\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nexport const escapeQuery = (query:string):string => {\n\treturn query.replace(/['\"\\\\]/g, '\\\\$&');\n}\n\n/**\n * Dispatch an event\n *\n */\nexport const triggerEvent = ( dom_el:HTMLElement, event_name:string ):void => {\n\tvar event = document.createEvent('HTMLEvents');\n\tevent.initEvent(event_name, true, false);\n\tdom_el.dispatchEvent(event)\n};\n\n/**\n * Apply CSS rules to a dom element\n *\n */\nexport const applyCSS = ( dom_el:HTMLElement, css:{ [key: string]: string|number }):void => {\n\tObject.assign(dom_el.style, css);\n}\n\n\n/**\n * Add css classes\n *\n */\nexport const addClasses = ( elmts:HTMLElement|HTMLElement[], ...classes:string[]|string[][] ) => {\n\n\tvar norm_classes \t= classesArray(classes);\n\telmts\t\t\t\t= castAsArray(elmts);\n\n\telmts.map( el => {\n\t\tnorm_classes.map( cls => {\n\t\t\tel.classList.add( cls );\n\t\t});\n\t});\n}\n\n/**\n * Remove css classes\n *\n */\n export const removeClasses = ( elmts:HTMLElement|HTMLElement[], ...classes:string[]|string[][] ) => {\n\n \tvar norm_classes \t= classesArray(classes);\n\telmts\t\t\t\t= castAsArray(elmts);\n\n\telmts.map( el => {\n\t\tnorm_classes.map(cls => {\n\t \t\tel.classList.remove( cls );\n\t\t});\n \t});\n }\n\n\n/**\n * Return arguments\n *\n */\nexport const classesArray = (args:string[]|string[][]):string[] => {\n\tvar classes:string[] = [];\n\titerate( args, (_classes) =>{\n\t\tif( typeof _classes === 'string' ){\n\t\t\t_classes = _classes.trim().split(/[\\11\\12\\14\\15\\40]/);\n\t\t}\n\t\tif( Array.isArray(_classes) ){\n\t\t\tclasses = classes.concat(_classes);\n\t\t}\n\t});\n\n\treturn classes.filter(Boolean);\n}\n\n\n/**\n * Create an array from arg if it's not already an array\n *\n */\nexport const castAsArray = (arg:any):Array<any> => {\n\tif( !Array.isArray(arg) ){\n \t\targ = [arg];\n \t}\n\treturn arg;\n}\n\n\n/**\n * Get the closest node to the evt.target matching the selector\n * Stops at wrapper\n *\n */\nexport const parentMatch = ( target:null|HTMLElement, selector:string, wrapper?:HTMLElement ):HTMLElement|void => {\n\n\tif( wrapper && !wrapper.contains(target) ){\n\t\treturn;\n\t}\n\n\twhile( target && target.matches ){\n\n\t\tif( target.matches(selector) ){\n\t\t\treturn target;\n\t\t}\n\n\t\ttarget = target.parentNode as HTMLElement;\n\t}\n}\n\n\n/**\n * Get the first or last item from an array\n *\n * > 0 - right (last)\n * <= 0 - left (first)\n *\n */\nexport const getTail = ( list:Array<any>|NodeList, direction:number=0 ):any => {\n\n\tif( direction > 0 ){\n\t\treturn list[list.length-1];\n\t}\n\n\treturn list[0];\n}\n\n/**\n * Return true if an object is empty\n *\n */\nexport const isEmptyObject = (obj:object):boolean => {\n\treturn (Object.keys(obj).length === 0);\n}\n\n\n/**\n * Get the index of an element amongst sibling nodes of the same type\n *\n */\nexport const nodeIndex = ( el:null|Element, amongst?:string ):number => {\n\tif (!el) return -1;\n\n\tamongst = amongst || el.nodeName;\n\n\tvar i = 0;\n\twhile( el = el.previousElementSibling ){\n\n\t\tif( el.matches(amongst) ){\n\t\t\ti++;\n\t\t}\n\t}\n\treturn i;\n}\n\n\n/**\n * Set attributes of an element\n *\n */\nexport const setAttr = (el:Element,attrs:{ [key: string]: null|string|number }) => {\n\titerate( attrs,(val,attr) => {\n\t\tif( val == null ){\n\t\t\tel.removeAttribute(attr as string);\n\t\t}else{\n\t\t\tel.setAttribute(attr as string, ''+val);\n\t\t}\n\t});\n}\n\n\n/**\n * Replace a node\n */\nexport const replaceNode = ( existing:Node, replacement:Node ) => {\n\tif( existing.parentNode ) existing.parentNode.replaceChild(replacement, existing);\n}\n","/**\n * Plugin: \"dropdown_input\" (Tom Select)\n * Copyright (c) contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this\n * file except in compliance with the License. You may obtain a copy of the License at:\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n * ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n *\n */\n\nimport TomSelect from '../../tom-select';\nimport { nodeIndex, removeClasses } from '../../vanilla';\n\n\nexport default function(this:TomSelect) {\n\tvar self = this;\n\n\t/**\n\t * Moves the caret to the specified index.\n\t *\n\t * The input must be moved by leaving it in place and moving the\n\t * siblings, due to the fact that focus cannot be restored once lost\n\t * on mobile webkit devices\n\t *\n\t */\n\tself.hook('instead','setCaret',(new_pos:number) => {\n\n\t\tif( self.settings.mode === 'single' || !self.control.contains(self.control_input) ) {\n\t\t\tnew_pos = self.items.length;\n\t\t} else {\n\t\t\tnew_pos = Math.max(0, Math.min(self.items.length, new_pos));\n\n\t\t\tif( new_pos != self.caretPos && !self.isPending ){\n\n\t\t\t\tself.controlChildren().forEach((child,j) => {\n\t\t\t\t\tif( j < new_pos ){\n\t\t\t\t\t\tself.control_input.insertAdjacentElement('beforebegin', child );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.control.appendChild( child );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tself.caretPos = new_pos;\n\t});\n\n\tself.hook('instead','moveCaret',(direction:number) => {\n\n\t\tif( !self.isFocused ) return;\n\n\t\t// move caret before or after selected items\n\t\tconst last_active\t\t= self.getLastActive(direction);\n\t\tif( last_active ){\n\t\t\tconst idx = nodeIndex(last_active);\n\t\t\tself.setCaret(direction > 0 ? idx + 1: idx);\n\t\t\tself.setActiveItem();\n\t\t\tremoveClasses(last_active as HTMLElement,'last-active');\n\n\t\t// move caret left or right of current position\n\t\t}else{\n\t\t\tself.setCaret(self.caretPos + direction);\n\n\t\t}\n\n\t});\n\n};\n"],"names":["latin_convert","RegExp","Object","keys","join","iterate","object","callback","Array","isArray","forEach","key","hasOwnProperty","removeClasses","elmts","classes","norm_classes","classesArray","castAsArray","map","el","cls","classList","remove","args","_classes","trim","split","concat","filter","Boolean","arg","nodeIndex","amongst","nodeName","i","previousElementSibling","matches","self","hook","new_pos","settings","mode","control","contains","control_input","items","length","Math","max","min","caretPos","isPending","controlChildren","child","j","insertAdjacentElement","appendChild","direction","isFocused","last_active","getLastActive","idx","setCaret","setActiveItem"],"mappings":"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"}