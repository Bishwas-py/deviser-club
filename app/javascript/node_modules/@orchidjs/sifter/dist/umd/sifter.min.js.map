{"version":3,"file":"sifter.min.js","sources":["../../lib/diacritics.ts","../../lib/utils.ts","../../lib/sifter.ts"],"sourcesContent":["\n// @ts-ignore TS2691 \"An import path cannot end with a '.ts' extension\"\nimport { escape_regex } from './utils.ts';\n\ntype TDiacraticList = {[key:string]:string};\n\n// https://github.com/andrewrk/node-diacritics/blob/master/index.js\n\nvar latin_pat:RegExp;\nconst accent_pat = '[\\u0300-\\u036F\\u{b7}\\u{2be}]'; // \\u{2bc}\nconst accent_reg = new RegExp(accent_pat,'gu');\nvar diacritic_patterns:TDiacraticList;\n\nconst latin_convert:TDiacraticList = {\n\t'æ': 'ae',\n\t'ⱥ': 'a',\n\t'ø': 'o',\n};\n\nconst convert_pat = new RegExp(Object.keys(latin_convert).join('|'),'gu');\n\nconst code_points:[[number,number]] = [[ 0, 65535 ]];\n\n/**\n * Remove accents\n * via https://github.com/krisk/Fuse/issues/133#issuecomment-318692703\n *\n */\nexport const asciifold = (str:string):string => {\n\treturn str\n\t\t.normalize('NFKD')\n\t\t.replace(accent_reg, '')\n\t\t.toLowerCase()\n\t\t.replace(convert_pat,function(foreignletter) {\n\t\t\treturn latin_convert[foreignletter];\n\t\t});\n};\n\n/**\n * Convert array of strings to a regular expression\n *\tex ['ab','a'] => (?:ab|a)\n * \tex ['a','b'] => [ab]\n *\n */\nexport const arrayToPattern = (chars:string[],glue:string='|'):string =>{\n\n\tif( chars.length == 1 ){\n\t\treturn chars[0];\n\t}\n\n\tvar longest = 1;\n\tchars.forEach((a)=>{longest = Math.max(longest,a.length)});\n\n\tif( longest == 1 ){\n\t\treturn '['+chars.join('')+']';\n\t}\n\n\treturn '(?:'+chars.join(glue)+')';\n};\n\nexport const escapeToPattern = (chars:string[]):string =>{\n\tconst escaped = chars.map((diacritic) => escape_regex(diacritic));\n\treturn arrayToPattern(escaped);\n};\n\n/**\n * Get all possible combinations of substrings that add up to the given string\n * https://stackoverflow.com/questions/30169587/find-all-the-combination-of-substrings-that-add-up-to-the-given-string\n *\n */\nexport const allSubstrings = (input:string):string[][] => {\n\n    if( input.length === 1) return [[input]];\n\n    var result:string[][] = [];\n    allSubstrings(input.substring(1)).forEach(function(subresult) {\n        var tmp = subresult.slice(0);\n        tmp[0] = input.charAt(0) + tmp[0];\n        result.push(tmp);\n\n        tmp = subresult.slice(0);\n        tmp.unshift(input.charAt(0));\n        result.push(tmp);\n    });\n\n    return result;\n}\n\n/**\n * Generate a list of diacritics from the list of code points\n *\n */\nexport const generateDiacritics = (code_points:[[number,number]]):TDiacraticList => {\n\n\tvar diacritics:{[key:string]:string[]} = {};\n\tcode_points.forEach((code_range)=>{\n\n\t\tfor(let i = code_range[0]; i <= code_range[1]; i++){\n\n\t\t\tlet diacritic\t= String.fromCharCode(i);\n\t\t\tlet\tlatin\t\t= asciifold(diacritic);\n\n\t\t\tif( latin == diacritic.toLowerCase() ){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// skip when latin is a string longer than 3 characters long\n\t\t\t// bc the resulting regex patterns will be long\n\t\t\t// eg:\n\t\t\t// latin صلى الله عليه وسلم length 18 code point 65018\n\t\t\t// latin جل جلاله length 8 code point 65019\n\t\t\tif( latin.length > 3 ){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif( !(latin in diacritics) ){\n\t\t\t\tdiacritics[latin] = [latin];\n\t\t\t}\n\n\t\t\tvar patt = new RegExp( escapeToPattern(diacritics[latin]),'iu');\n\t\t\tif( diacritic.match(patt) ){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdiacritics[latin].push(diacritic);\n\t\t}\n\t});\n\n\t// filter out if there's only one character in the list\n\tlet latin_chars = Object.keys(diacritics);\n\tfor( let i = 0; i < latin_chars.length; i++){\n\t\tconst latin = latin_chars[i];\n\t\tif( diacritics[latin].length < 2 ){\n\t\t\tdelete diacritics[latin];\n\t\t}\n\t}\n\n\n\t// latin character pattern\n\t// match longer substrings first\n\tlatin_chars\t\t= Object.keys(diacritics).sort((a, b) => b.length - a.length );\n\tlatin_pat\t\t= new RegExp('('+ escapeToPattern(latin_chars) + accent_pat + '*)','gu');\n\n\n\t// build diacritic patterns\n\t// ae needs:\n\t//\t(?:(?:ae|Æ|Ǽ|Ǣ)|(?:A|Ⓐ|Ａ...)(?:E|ɛ|Ⓔ...))\n\tvar diacritic_patterns:TDiacraticList = {};\n\tlatin_chars.sort((a,b) => a.length -b.length).forEach((latin)=>{\n\n\t\tvar substrings\t= allSubstrings(latin);\n\t\tvar pattern = substrings.map((sub_pat)=>{\n\n\t\t\tsub_pat = sub_pat.map((l)=>{\n\t\t\t\tif( diacritics.hasOwnProperty(l) ){\n\t\t\t\t\treturn escapeToPattern(diacritics[l]);\n\t\t\t\t}\n\t\t\t\treturn l;\n\t\t\t});\n\n\t\t\treturn arrayToPattern(sub_pat,'');\n\t\t});\n\n\t\tdiacritic_patterns[latin] = arrayToPattern(pattern);\n\t});\n\n\n\treturn diacritic_patterns;\n}\n\n/**\n * Expand a regular expression pattern to include diacritics\n * \teg /a/ becomes /aⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐɑAⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ/\n *\n */\nexport const diacriticRegexPoints = (regex:string):string => {\n\n\tif( diacritic_patterns === undefined ){\n\t\tdiacritic_patterns = generateDiacritics(code_points);\n\t}\n\n\tconst decomposed\t\t= regex.normalize('NFKD').toLowerCase();\n\n\treturn decomposed.split(latin_pat).map((part:string)=>{\n\n\t\t// \"ﬄ\" or \"ffl\"\n\t\tconst no_accent = asciifold(part);\n\t\tif( no_accent == '' ){\n\t\t\treturn '';\n\t\t}\n\n\t\tif( diacritic_patterns.hasOwnProperty(no_accent) ){\n\t\t\treturn diacritic_patterns[no_accent];\n\t\t}\n\n\t\treturn part;\n\t}).join('');\n\n}\n","\n// @ts-ignore TS2691 \"An import path cannot end with a '.ts' extension\"\nimport { asciifold } from './diacritics.ts';\n\n// @ts-ignore TS2691 \"An import path cannot end with a '.ts' extension\"\nimport * as T from './types.ts';\n\n\n/**\n * A property getter resolving dot-notation\n * @param  {Object}  obj     The root object to fetch property on\n * @param  {String}  name    The optionally dotted property name to fetch\n * @return {Object}          The resolved property value\n */\nexport const getAttr = (obj:{[key:string]:any}, name:string ) => {\n    if (!obj ) return;\n    return obj[name];\n};\n\n/**\n * A property getter resolving dot-notation\n * @param  {Object}  obj     The root object to fetch property on\n * @param  {String}  name    The optionally dotted property name to fetch\n * @return {Object}          The resolved property value\n */\nexport const getAttrNesting = (obj:{[key:string]:any}, name:string ) => {\n    if (!obj ) return;\n    var part, names = name.split(\".\");\n\twhile( (part = names.shift()) && (obj = obj[part]));\n    return obj;\n};\n\n/**\n * Calculates how close of a match the\n * given value is against a search token.\n *\n */\nexport const scoreValue = (value:string, token:T.Token, weight:number ):number => {\n\tvar score, pos;\n\n\tif (!value) return 0;\n\n\tvalue = value + '';\n\tpos = value.search(token.regex);\n\tif (pos === -1) return 0;\n\n\tscore = token.string.length / value.length;\n\tif (pos === 0) score += 0.5;\n\n\treturn score * weight;\n};\n\n/**\n *\n * https://stackoverflow.com/questions/63006601/why-does-u-throw-an-invalid-escape-error\n */\nexport const escape_regex = (str:string):string => {\n\treturn (str + '').replace(/([\\$\\(\\)\\*\\+\\.\\?\\[\\]\\^\\{\\|\\}\\\\])/gu, '\\\\$1');\n};\n\n\n/**\n * Cast object property to an array if it exists and has a value\n *\n */\nexport const propToArray = (obj:{[key:string]:any}, key:string) => {\n\tvar value = obj[key];\n\n\tif( typeof value == 'function' ) return value;\n\n\tif( value && !Array.isArray(value) ){\n\t\tobj[key] = [value];\n\t}\n}\n\n\n/**\n * Iterates over arrays and hashes.\n *\n * ```\n * iterate(this.items, function(item, id) {\n *    // invoked for each item\n * });\n * ```\n *\n */\nexport const iterate = (object:[]|{[key:string]:any}, callback:(value:any,key:number|string)=>any) => {\n\n\tif ( Array.isArray(object)) {\n\t\tobject.forEach(callback);\n\n\t}else{\n\n\t\tfor (var key in object) {\n\t\t\tif (object.hasOwnProperty(key)) {\n\t\t\t\tcallback(object[key], key);\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n\nexport const cmp = (a:number|string, b:number|string) => {\n\tif (typeof a === 'number' && typeof b === 'number') {\n\t\treturn a > b ? 1 : (a < b ? -1 : 0);\n\t}\n\ta = asciifold(a + '').toLowerCase();\n\tb = asciifold(b + '').toLowerCase();\n\tif (a > b) return 1;\n\tif (b > a) return -1;\n\treturn 0;\n};\n","/**\n * sifter.js\n * Copyright (c) 2013–2020 Brian Reavis & contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this\n * file except in compliance with the License. You may obtain a copy of the License at:\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n * ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n *\n * @author Brian Reavis <brian@thirdroute.com>\n */\n\n // @ts-ignore TS2691 \"An import path cannot end with a '.ts' extension\"\nimport { scoreValue, getAttr, getAttrNesting, escape_regex, propToArray, iterate, cmp } from './utils.ts';\n// @ts-ignore TS2691 \"An import path cannot end with a '.ts' extension\"\nimport { diacriticRegexPoints } from './diacritics.ts';\n// @ts-ignore TS2691 \"An import path cannot end with a '.ts' extension\"\nimport * as T from 'types.ts';\n\nexport default class Sifter{\n\n\tpublic items; // []|{};\n\tpublic settings: T.Settings;\n\n\t/**\n\t * Textually searches arrays and hashes of objects\n\t * by property (or multiple properties). Designed\n\t * specifically for autocomplete.\n\t *\n\t */\n\tconstructor(items:any, settings:T.Settings) {\n\t\tthis.items = items;\n\t\tthis.settings = settings || {diacritics: true};\n\t};\n\n\t/**\n\t * Splits a search string into an array of individual\n\t * regexps to be used to match results.\n\t *\n\t */\n\ttokenize(query:string, respect_word_boundaries?:boolean, weights?:T.Weights ):T.Token[] {\n\t\tif (!query || !query.length) return [];\n\n\t\tconst tokens:T.Token[]\t= [];\n\t\tconst words\t\t\t\t= query.split(/\\s+/);\n\t\tvar field_regex:RegExp;\n\n\t\tif( weights ){\n\t\t\tfield_regex = new RegExp( '^('+ Object.keys(weights).map(escape_regex).join('|')+')\\:(.*)$');\n\t\t}\n\n\t\twords.forEach((word:string) => {\n\t\t\tlet field_match;\n\t\t\tlet field:null|string\t= null;\n\t\t\tlet regex:null|string\t= null;\n\n\t\t\t// look for \"field:query\" tokens\n\t\t\tif( field_regex && (field_match = word.match(field_regex)) ){\n\t\t\t\tfield\t= field_match[1];\n\t\t\t\tword\t= field_match[2];\n\t\t\t}\n\n\t\t\tif( word.length > 0 ){\n\t\t\t\tif( this.settings.diacritics ){\n\t\t\t\t\tregex = diacriticRegexPoints(word);\n\t\t\t\t}else{\n\t\t\t\t\tregex = escape_regex(word);\n\t\t\t\t}\n\t\t\t\tif( respect_word_boundaries ) regex = \"\\\\b\"+regex;\n\t\t\t}\n\n\t\t\ttokens.push({\n\t\t\t\tstring : word,\n\t\t\t\tregex  : regex ? new RegExp(regex,'iu') : null,\n\t\t\t\tfield  : field,\n\t\t\t});\n\t\t});\n\n\t\treturn tokens;\n\t};\n\n\n\t/**\n\t * Returns a function to be used to score individual results.\n\t *\n\t * Good matches will have a higher score than poor matches.\n\t * If an item is not a match, 0 will be returned by the function.\n\t *\n\t * @returns {function}\n\t */\n\tgetScoreFunction(query:string, options:T.Options ){\n\t\tvar search = this.prepareSearch(query, options);\n\t\treturn this._getScoreFunction(search);\n\t}\n\n\t_getScoreFunction(search:T.PrepareObj ){\n\t\tconst tokens\t\t= search.tokens,\n\t\ttoken_count\t\t\t= tokens.length;\n\n\t\tif (!token_count) {\n\t\t\treturn function() { return 0; };\n\t\t}\n\n\t\tconst fields\t= search.options.fields,\n\t\tweights\t\t\t= search.weights,\n\t\tfield_count\t\t= fields.length,\n\t\tgetAttrFn\t\t= search.getAttrFn;\n\n\t\tif (!field_count) {\n\t\t\treturn function() { return 1; };\n\t\t}\n\n\n\t\t/**\n\t\t * Calculates the score of an object\n\t\t * against the search query.\n\t\t *\n\t\t */\n\t\tconst scoreObject = (function() {\n\n\n\t\t\tif (field_count === 1) {\n\t\t\t\treturn function(token:T.Token, data:{}) {\n\t\t\t\t\tconst field = fields[0].field;\n\t\t\t\t\treturn scoreValue(getAttrFn(data, field), token, weights[field]);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn function(token:T.Token, data:{}) {\n\t\t\t\tvar sum = 0;\n\n\t\t\t\t// is the token specific to a field?\n\t\t\t\tif( token.field ){\n\n\t\t\t\t\tconst value = getAttrFn(data, token.field);\n\n\t\t\t\t\tif( !token.regex && value ){\n\t\t\t\t\t\tsum += (1/field_count);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsum += scoreValue(value, token, 1);\n\t\t\t\t\t}\n\n\n\n\t\t\t\t}else{\n\t\t\t\t\titerate(weights, (weight:number, field:string) => {\n\t\t\t\t\t\tsum += scoreValue(getAttrFn(data, field), token, weight);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn sum / field_count;\n\t\t\t};\n\t\t})();\n\n\t\tif (token_count === 1) {\n\t\t\treturn function(data:{}) {\n\t\t\t\treturn scoreObject(tokens[0], data);\n\t\t\t};\n\t\t}\n\n\t\tif (search.options.conjunction === 'and') {\n\t\t\treturn function(data:{}) {\n\t\t\t\tvar i = 0, score, sum = 0;\n\t\t\t\tfor (; i < token_count; i++) {\n\t\t\t\t\tscore = scoreObject(tokens[i], data);\n\t\t\t\t\tif (score <= 0) return 0;\n\t\t\t\t\tsum += score;\n\t\t\t\t}\n\t\t\t\treturn sum / token_count;\n\t\t\t};\n\t\t} else {\n\t\t\treturn function(data:{}) {\n\t\t\t\tvar sum = 0;\n\t\t\t\titerate(tokens,(token:T.Token)=>{\n\t\t\t\t\tsum += scoreObject(token, data);\n\t\t\t\t});\n\t\t\t\treturn sum / token_count;\n\t\t\t};\n\t\t}\n\t};\n\n\t/**\n\t * Returns a function that can be used to compare two\n\t * results, for sorting purposes. If no sorting should\n\t * be performed, `null` will be returned.\n\t *\n\t * @return function(a,b)\n\t */\n\tgetSortFunction(query:string, options:T.Options) {\n\t\tvar search  = this.prepareSearch(query, options);\n\t\treturn this._getSortFunction(search);\n\t}\n\n\t_getSortFunction(search:T.PrepareObj){\n\t\tvar i, n, implicit_score;\n\n\t\tconst self\t= this,\n\t\toptions\t\t= search.options,\n\t\tsort\t\t= (!search.query && options.sort_empty) ? options.sort_empty : options.sort,\n\t\tsort_flds:T.Sort[]\t\t= [],\n\t\tmultipliers:number[]\t= [];\n\n\n\t\tif( typeof sort == 'function' ){\n\t\t\treturn sort.bind(this);\n\t\t}\n\n\t\t/**\n\t\t * Fetches the specified sort field value\n\t\t * from a search result item.\n\t\t *\n\t\t */\n\t\tconst get_field = function(name:string, result:T.ResultItem):string|number {\n\t\t\tif (name === '$score') return result.score;\n\t\t\treturn search.getAttrFn(self.items[result.id], name);\n\t\t};\n\n\t\t// parse options\n\t\tif (sort) {\n\t\t\tfor (i = 0, n = sort.length; i < n; i++) {\n\t\t\t\tif (search.query || sort[i].field !== '$score') {\n\t\t\t\t\tsort_flds.push(sort[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// the \"$score\" field is implied to be the primary\n\t\t// sort field, unless it's manually specified\n\t\tif (search.query) {\n\t\t\timplicit_score = true;\n\t\t\tfor (i = 0, n = sort_flds.length; i < n; i++) {\n\t\t\t\tif (sort_flds[i].field === '$score') {\n\t\t\t\t\timplicit_score = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (implicit_score) {\n\t\t\t\tsort_flds.unshift({field: '$score', direction: 'desc'});\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0, n = sort_flds.length; i < n; i++) {\n\t\t\t\tif (sort_flds[i].field === '$score') {\n\t\t\t\t\tsort_flds.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, n = sort_flds.length; i < n; i++) {\n\t\t\tmultipliers.push(sort_flds[i].direction === 'desc' ? -1 : 1);\n\t\t}\n\n\t\t// build function\n\t\tconst sort_flds_count = sort_flds.length;\n\t\tif (!sort_flds_count) {\n\t\t\treturn null;\n\t\t} else if (sort_flds_count === 1) {\n\t\t\tconst sort_fld = sort_flds[0].field;\n\t\t\tconst multiplier = multipliers[0];\n\t\t\treturn function(a:T.ResultItem, b:T.ResultItem) {\n\t\t\t\treturn multiplier * cmp(\n\t\t\t\t\tget_field(sort_fld, a),\n\t\t\t\t\tget_field(sort_fld, b)\n\t\t\t\t);\n\t\t\t};\n\t\t} else {\n\t\t\treturn function(a:T.ResultItem, b:T.ResultItem) {\n\t\t\t\tvar i, result, field;\n\t\t\t\tfor (i = 0; i < sort_flds_count; i++) {\n\t\t\t\t\tfield = sort_flds[i].field;\n\t\t\t\t\tresult = multipliers[i] * cmp(\n\t\t\t\t\t\tget_field(field, a),\n\t\t\t\t\t\tget_field(field, b)\n\t\t\t\t\t);\n\t\t\t\t\tif (result) return result;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t};\n\t\t}\n\t};\n\n\t/**\n\t * Parses a search query and returns an object\n\t * with tokens and fields ready to be populated\n\t * with results.\n\t *\n\t */\n\tprepareSearch(query:string, optsUser:Partial<T.Options>):T.PrepareObj {\n\t\tconst weights:T.Weights = {};\n\t\tvar options\t\t= Object.assign({},optsUser);\n\n\t\tpropToArray(options,'sort');\n\t\tpropToArray(options,'sort_empty');\n\n\t\t// convert fields to new format\n\t\tif( options.fields ){\n\t\t\tpropToArray(options,'fields');\n\t\t\tconst fields:T.Field[] = [];\n\t\t\toptions.fields.forEach((field:string|T.Field) => {\n\t\t\t\tif( typeof field == 'string' ){\n\t\t\t\t\tfield = {field:field,weight:1};\n\t\t\t\t}\n\t\t\t\tfields.push(field);\n\t\t\t\tweights[field.field] = ('weight' in field) ? field.weight : 1;\n\t\t\t});\n\t\t\toptions.fields = fields;\n\t\t}\n\n\n\t\treturn {\n\t\t\toptions\t\t: options,\n\t\t\tquery\t\t: query.toLowerCase().trim(),\n\t\t\ttokens\t\t: this.tokenize(query, options.respect_word_boundaries, weights),\n\t\t\ttotal\t\t: 0,\n\t\t\titems\t\t: [],\n\t\t\tweights\t\t: weights,\n\t\t\tgetAttrFn\t: (options.nesting) ? getAttrNesting : getAttr,\n\t\t};\n\t};\n\n\t/**\n\t * Searches through all items and returns a sorted array of matches.\n\t *\n\t */\n\tsearch(query:string, options:T.Options) : T.PrepareObj {\n\t\tvar self = this, score, search:T.PrepareObj;\n\n\t\tsearch  = this.prepareSearch(query, options);\n\t\toptions = search.options;\n\t\tquery   = search.query;\n\n\t\t// generate result scoring function\n\t\tconst fn_score = options.score || self._getScoreFunction(search);\n\n\t\t// perform search and sort\n\t\tif (query.length) {\n\t\t\titerate(self.items, (item:T.ResultItem, id:string|number) => {\n\t\t\t\tscore = fn_score(item);\n\t\t\t\tif (options.filter === false || score > 0) {\n\t\t\t\t\tsearch.items.push({'score': score, 'id': id});\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\titerate(self.items, (_:T.ResultItem, id:string|number) => {\n\t\t\t\tsearch.items.push({'score': 1, 'id': id});\n\t\t\t});\n\t\t}\n\n\t\tconst fn_sort = self._getSortFunction(search);\n\t\tif (fn_sort) search.items.sort(fn_sort);\n\n\t\t// apply limits\n\t\tsearch.total = search.items.length;\n\t\tif (typeof options.limit === 'number') {\n\t\t\tsearch.items = search.items.slice(0, options.limit);\n\t\t}\n\n\t\treturn search;\n\t};\n}\n"],"names":["latin_pat","accent_pat","accent_reg","RegExp","diacritic_patterns","latin_convert","convert_pat","Object","keys","join","code_points","asciifold","str","normalize","replace","toLowerCase","foreignletter","arrayToPattern","chars","glue","length","longest","forEach","a","Math","max","escapeToPattern","escaped","map","diacritic","escape_regex","allSubstrings","input","result","substring","subresult","tmp","slice","charAt","push","unshift","diacriticRegexPoints","regex","undefined","diacritics","code_range","i","String","fromCharCode","latin","patt","match","latin_chars","sort","b","pattern","sub_pat","l","hasOwnProperty","generateDiacritics","split","part","no_accent","getAttr","obj","name","getAttrNesting","names","shift","scoreValue","value","token","weight","score","pos","search","string","propToArray","key","Array","isArray","iterate","object","callback","cmp","constructor","items","settings","tokenize","query","respect_word_boundaries","weights","tokens","words","field_regex","word","field_match","field","this","getScoreFunction","options","prepareSearch","_getScoreFunction","token_count","fields","field_count","getAttrFn","scoreObject","data","sum","conjunction","getSortFunction","_getSortFunction","n","implicit_score","self","sort_empty","sort_flds","multipliers","bind","get_field","id","direction","splice","sort_flds_count","sort_fld","multiplier","optsUser","assign","trim","total","nesting","fn_score","item","filter","_","fn_sort","limit"],"mappings":"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"}